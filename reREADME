/**
实现一个使用golang便携的使用protobuf协议的简易RPC框架
测试文件中包括的是一个client端向service端写文件的过程
protobuf官方介绍：https://github.com/google/protobuf

Windows安装golang支持的protobuf
<1> windows下载golang（）配置GOROOT,GOBIN,GOPATH。其中GOROOT是golang的解压路径，GOBIN是%GOROOT%\bin,GOPATH是项目路径
<2> 下载 hb或者git，推荐git(https://git-scm.com/download/win)
<3> 下载 protoc （https://developers.google.com/protocol-buffers/docs/downloads），下载后会是一个zip，解压后把protoc.exe拷贝到GOBIN目录下
<4> 获取并安装proto-gen-go, go get github.com/golang/protobuf/protoc-gen-go, 这条命令会生成protoc-gen-go的可执行文件，
      这个命令会在GOBIN目录下生成protoc-gen-go.exe文件
<5>获取 goprotobuf 提供的支持库，包含诸如marshal、unmarshal等功能, 使用命令 go get github.com/golang/protobuf/proto.


测试：
首先我们需要写一个test.proto文件, 在这个文件中可以定义需要的结构, 例如枚举型, 结构体等等. 那么首先我自己定义了一个结构如下所示,

// test.proto
 package test;
 message myMsg
 {
    required int32     id = 1;   // ID
    required string    str = 2;  // str
    optional int32     opt = 3;  //optional field
 }
注意required是必须要求的字段, optional是可选字段. 同时注意, id=1, 后面的数字仅仅是一个unique标志而已, 保证唯一性就OK! 
然后使用protoc test.proto --go_out=. 编译这个文件, 生成的文件名称为test.pb.go文件! 如果这个路径下有多个文件需要编译, 那么执行protoc --go_out=. *.proto就可以. 注意--go_out=后面的参数是生成的文件的路径, 本文生成的文件在'.'当前路径下. 
生成的代码如下:

// Code generated by protoc-gen-go.
// source: 1.proto
// DO NOT EDIT!

/*
Package test is a generated protocol buffer package.

It is generated from these files:
    1.proto

It has these top-level messages:
    MyMsg
*/
package test

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type MyMsg struct {
    Id               *int32  `protobuf:"varint,1,req,name=id" json:"id,omitempty" bson:"id,omitempty"`
    Str              *string `protobuf:"bytes,2,req,name=str" json:"str,omitempty" bson:"str,omitempty"`
    Opt              *int32  `protobuf:"varint,3,opt,name=opt" json:"opt,omitempty" bson:"opt,omitempty"`
    XXX_unrecognized []byte  `json:"-"`
}

func (m *MyMsg) Reset()         { *m = MyMsg{} }
func (m *MyMsg) String() string { return proto.CompactTextString(m) }
func (*MyMsg) ProtoMessage()    {}

func (m *MyMsg) GetId() int32 {
    if m != nil && m.Id != nil {
        return *m.Id
    }
    return 0
}

func (m *MyMsg) GetStr() string {
    if m != nil && m.Str != nil {
        return *m.Str
    }
    return ""
}

func (m *MyMsg) GetOpt() int32 {
    if m != nil && m.Opt != nil {
        return *m.Opt
    }
    return 0
}

func init() {
}
特别注意: 生成的文件中的package是test, 那么文件必须放在test文件夹下! 否则会报错: "can't load package: package test: found packages test (test.pb.go) and main (main.go)"


下面写一个测试程序:

// main.go
package main

import (
    "fmt"
    t "./test"
    "github.com/golang/protobuf/proto"
)

func main(){
    // 创建一个对象, 并填充字段, 可以使用proto中的类型函数来处理例如Int32(XXX)
    hw := t.MyMsg{
        Id: proto.Int32(1),
        Str: proto.String("iyviasbjasdv"),
        Opt: proto.Int32(2),

    }

    // 对数据进行编码, 注意参数是message指针
    mData, err := proto.Marshal(&hw)

    if err != nil {
        fmt.Println("Error1: ", err)
        return
    }

    // 下面进行解码, 注意参数
    var umData t.MyMsg
    err = proto.Unmarshal(mData, &umData)

    if err != nil {
        fmt.Println("Error2: ", err)
        return
    }

    // 输出结果
    fmt.Println(*umData.Id, "  ", *umData.Str, "  ", *umData.Opt)
}

*/
